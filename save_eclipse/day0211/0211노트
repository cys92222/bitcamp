<< 상태유지 기법 >> 

쿠키	: 사용자의 정보를 사용자의 하드디스크에 기록하는 방식
			문자열만 저장할 수 있어요.
			
			쿠키값으로 한글을 저장하려면 다음과 같이 변환한 후 저장해야해요.
				URLEncoder.encode(쿠키값, "utf-8");
			
			읽어올때는 다음과 같이 변환 후 읽어와야해요.
				URLDecoder.decode(쿠키값, "utf-8");
			
			
세션	: 사용자의 정보를 서버에 기록하는 방식
			내장객체가 제공됨
			어떤 자료형이라도 저장할 수 있어요.
			
			세션의 값을 설정하기 위해서는 다음과 같이 사용해요. 
				session.setAttribute("변수명", 값);
			변수명은 문자열, 값은 어떤 자료형이라도 좋아요. 
			
			세션값을 읽어오기 위해서는 다음과 같이 사용해요. 
				sessiion.getAttribute(변수명);
				
				getAttribute은 Object를 반환하기 때문에 원하는 자료형으로 변환해서 처리해야 해요.
			
=========================================================================================================

<< 상태유지를 위한 jsp 내장객체들 >>

pageContext		: 현재 페이지에서만 유효해요.	
request			: 다음 연결된 문서까지만 유효해요.
session			: 세션이 유지되기 전(브라우저 닫기 전까지)까지 유효해요.
application		: 서버가 종료되기 전까지 유효해요.

위의 4가지는 사용법은 같아요.
	setAttribute
	getAttribute

===================================================================================================

<< 표현식과 표현언어 >>
request, session, application에 저장된 값을 출력하기 위하여 이제부터는 
표현언어를 사용합니다. 

<%=request.getAttribute("member1") %>	표현식

${member1 }								표현언어

====================================================================================================

<< jstl의 사용 >> 

jsp standard tag library 

가능하면 jsp문서에서 자바문법을 걷어내고 싶어요. 
(반복문, 선택문...)
반복문이나 선택문을 대신하는 태그 

========================================================================================================

MVC 패턴 

전통적인 jsp는 하나의 jsp안에서 모든 처리가 이루어져요. 
	사용자가 어떤서비스를 원하는지 서비스에 대한 요청도 jsp에게 하고 
	그 요청에 대한 처리도 jsp가 하고, 결과를 보여주기 위한 view 역할도 jsp가 담당합니다. 
	
	사용자 요구가 간단한 경우라면 하나의 jsp로 작성해도 되지만, 
	점점 더 사용자의 요구가 복잡해지고 또 빈번한 수정이 요구됨에 따라 
	하나의 jsp만으로 작성하기에는 불편함이 있어요. 
	
	따라서, 이것을 역할분담 합니다. 
	
	사용자의 요청에 대한 파악은 Controller 가 담당하고 
	그 요청에 따른 일처리는 Model이 담당하고 
	결과를 보여주기 위한 역할은 View가 담당하도록 해요. 
	
	이렇게 함으로써 협업이나, 유지보수가 수월해져요.
	
	이때 Controller는 서블릿으로 만드는것이 일반적입니다.
	즉, 사용자가 어떤 서비스를 원하는지 파악은 서블릿으로 표현합니다. 
	
	또, 일처리를 위한 Model은 별도의 자바클래스로 만들어서 처리해요. 
	
	결과를 보여주기 위한 역할의 View는 jsp로 표현해요. 
	
	따라서 jsp는 결과를 보여주기 위한 역할만 수행하도록 합니다.
	jsp문서안에서 자바문법이 사라지게 됩니다. 
	반복문이나 선택문을 대신하는 jstl태그를 이용합니다. 
	또, 출력을 위해서는 표현언어를 사용합니다.



======================================================================================================

listBook.do  라는 요청이름으로 서비스를 요청하면 
	ListBookServlet이 응답하여 
	DAO를 통해 모든 도서를 읽어와 
	request에 상태유지를 한 다음 
	결과를 보여주기위한 view페이지로(listBook.jsp) 이동시키도록 합니다. 
	listBook.jsp는 서블릿이 상태유지한 도서목록을 출력하는 담당만 하도록 합니다.

=============================================================================================================

<< 페이징 처리 >>
게시물 목록이 총 53개의 건수가 있습니다.
한 화면에 다 보이니 보기가 좋지 않아요. 
한 화면에 보여줄 게시물의 수를 10개씩 출력하고 싶어요.
다 못보여주는 내용은 하단에 페이지번호를 출력하고 
해당 페이지 번호를 누르면 그 페이지에 해당하는 게시물 목록을 출력하고 싶어요.

1) 페이징처리를 하려면 가장 먼저 
	전체 레코드의 수는 몇개인지 알아야해요. 

	totalRecord = 53

2) 한화면에 몇개씩 출력할지를 정해야해요. 
	
	pageSize = 10
	
3) 전체 페이지수를 계산합니다. 

	totalPage = totalRecord / pageSize;
	if( totalRecord %pageSize != 0 ){
			totalPage++;
		}
============================================================================================================

저는 총 53개의 레코드를 갖고있습니다.
한 화면에 10개씩 출력하고 싶어요.

현재페이지가 1페이지라면 
	몇번째 레코드부터 출력해야 할까요?
	시작 레코드의 번호는 1 
	마지막 레코드의 번호는 10
	
현재페이지가 2페이지라면 
	시작 레코드의 번호 11
	마지막 레코드의 번호 20 
	

totalRecord = 53;
pageSize = 10;

pageNUM = 2;
start = (pageNUM - 1 ) * pageSize + 1 ;
end = start + pageSize - 1;

============================================================================================================

현재페이지가 2페이지라고 가정하고 
start = 11
end = 20 
사이의 레코드를 출력하는 sql을 작성해봅시다. 


select no,title,writer,pwd,hit,regdate,content,fname,ip 
	from (select rownum n, no, title,writer,pwd,hit,regdate,content,fname,ip 
		from (select * from board order by no desc))
where n between 11 and 20;


select *
	from (select rownum n, no, title,writer,pwd,hit,regdate,content,fname,ip 
		from (select * from board order by no desc))
where n between 11 and 20;


============================================================================================================

한화면에 4개의 상품을 출력하도록 페이징처리를 구현해봅니다.

만약 페이지번호가 2페이지이면 
시작레코드의 위치는 5 
마지막레코드의 위치는 8

select fname, item, price 
	from (select rownum n, no, item, price, qty, fname, detail 
		from (select * from goods order by no ))
where n between 1 and 4;


============================================================================================================



































































































